//package ton.tlb.old
//
//import ton.tlb.old.TlbToken.*
//
///**
// * This class is a scanner generated by
// * [JFlex](http://www.jflex.de/) 1.7.0
// * from the specification file <tt>TlbLexer.flex</tt>
// */
//class TlbLexer {
//
//    /**
//     * the current state of the DFA
//     */
//    private var zzState = 0
//
//    /**
//     * the current lexical state
//     */
//    private var zzLexicalState = YYINITIAL
//
//    /**
//     * this buffer contains the current text to be matched and is
//     * the source of the yytext() string
//     */
//    private var zzBuffer: CharSequence = ""
//
//    /**
//     * the textposition at the last accepting state
//     */
//    private var zzMarkedPos = 0
//
//    /**
//     * the current text position in the buffer
//     */
//    private var zzCurrentPos = 0
//
//    /**
//     * startRead marks the beginning of the yytext() string in the buffer
//     */
//    var tokenStart = 0
//        private set
//
//    /**
//     * endRead marks the last character in the buffer, that has been read
//     * from input
//     */
//    private var zzEndRead = 0
//
//    /**
//     * zzAtBOL == true <=> the scanner is currently at the beginning of a line
//     */
//    private var zzAtBOL = true
//
//    /**
//     * zzAtEOF == true <=> the scanner is at the EOF
//     */
//    private var zzAtEOF = false
//
//    /**
//     * denotes if the user-EOF-code has already been executed
//     */
//    private var zzEOFDone = false
//
//    private class State(val state: Int, val lBraceCount: Int) {
//        override fun toString(): String {
//            return "yystate = " + state + if (lBraceCount == 0) "" else "lBraceCount = $lBraceCount"
//        }
//    }
//
//    private val states: ArrayDeque<State> = ArrayDeque()
//    private var lBraceCount = 0
//    private var commentStart = 0
//    private var commentDepth = 0
//    private fun pushState(state: Int) {
//        states.addLast(State(yystate(), lBraceCount))
//        lBraceCount = 0
//        yybegin(state)
//    }
//
//    private fun popState() {
//        val state: State = states.removeLast()
//        lBraceCount = state.lBraceCount
//        yybegin(state.state)
//    }
//
//    private fun commentStateToTokenType(state: Int): TlbToken {
//        when (state) {
//            BLOCK_COMMENT_STATE -> return BLOCK_COMMENT
//            DOC_COMMENT_STATE -> return BLOCK_DOCUMENTATION
//            else -> throw IllegalArgumentException("Unexpected state: $state")
//        }
//    }
//
//    val tokenEnd: Int
//        get() = tokenStart + yylength()
//
//    fun reset(buffer: CharSequence, start: Int = 0, end: Int = buffer.length, initialState: Int = 0) {
//        zzBuffer = buffer
//        tokenStart = start
//        zzMarkedPos = tokenStart
//        zzCurrentPos = zzMarkedPos
//        zzAtEOF = false
//        zzAtBOL = true
//        zzEndRead = end
//        yybegin(initialState)
//    }
//
//    /**
//     * Refills the input buffer.
//     *
//     * @return `false`, iff there was new input.
//     */
//    private fun zzRefill(): Boolean = true
//
//    /**
//     * Returns the current lexical state.
//     */
//    fun yystate(): Int = zzLexicalState
//
//    /**
//     * Enters a new lexical state
//     *
//     * @param newState the new lexical state
//     */
//    fun yybegin(newState: Int) {
//        zzLexicalState = newState
//    }
//
//    /**
//     * Returns the text matched by the current regular expression.
//     */
//    fun yytext(): CharSequence = zzBuffer.subSequence(tokenStart, zzMarkedPos)
//
//    /**
//     * Returns the character at position `pos` from the
//     * matched text.
//     *
//     *
//     * It is equivalent to yytext().charAt(pos), but faster
//     *
//     * @param pos the position of the character to fetch.
//     * A value from 0 to yylength()-1.
//     * @return the character at position pos
//     */
//    fun yycharat(pos: Int): Char = zzBuffer[tokenStart + pos]
//
//    /**
//     * Returns the length of the matched text region.
//     */
//    fun yylength(): Int = zzMarkedPos - tokenStart
//
//    /**
//     * Reports an error that occurred while scanning.
//     *
//     *
//     * In a wellformed scanner (no or only correct usage of
//     * yypushback(int) and a match-all fallback rule) this method
//     * will only be called with things that "Can't Possibly Happen".
//     * If this method is called, something is seriously wrong
//     * (e.g. a JFlex bug producing a faulty scanner etc.).
//     *
//     *
//     * Usual syntax/scanner level error handling should be done
//     * in error fallback rules.
//     *
//     * @param errorCode the code of the errormessage to display
//     */
//    private fun zzScanError(errorCode: Int) {
//        var message = try {
//            ZZ_ERROR_MSG[errorCode]
//        } catch (e: IndexOutOfBoundsException) {
//            ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR]
//        }
//        throw Error(message)
//    }
//
//    /**
//     * Pushes the specified amount of characters back into the input stream.
//     *
//     *
//     * They will be read again by then next call of the scanning method
//     *
//     * @param number the number of characters to be read again.
//     * This number must not be greater than yylength()!
//     */
//    fun yypushback(number: Int) {
//        if (number > yylength()) zzScanError(ZZ_PUSHBACK_2BIG)
//        zzMarkedPos -= number
//    }
//
//    /**
//     * Contains user EOF-code, which will be executed exactly once,
//     * when the end of file is reached
//     */
//    private fun zzDoEOF() {
//        if (!zzEOFDone) {
//            zzEOFDone = true
//            return
//        }
//    }
//
//    /**
//     * Resumes scanning until the next regular expression is matched,
//     * the end of input is encountered or an I/O-Error occurs.
//     *
//     * @return the next token
//     */
//    fun advance(): TlbToken? {
//        var zzInput: Int
//        var zzAction: Int
//
//        // cached fields:
//        var zzCurrentPosL: Int
//        var zzMarkedPosL: Int
//        var zzEndReadL = zzEndRead
//        var zzBufferL = zzBuffer
//        val zzTransL = ZZ_TRANS
//        val zzRowMapL = ZZ_ROWMAP
//        val zzAttrL = ZZ_ATTRIBUTE
//        while (true) {
//            zzMarkedPosL = zzMarkedPos
//            zzAction = -1
//            tokenStart = zzMarkedPosL
//            zzCurrentPos = tokenStart
//            zzCurrentPosL = zzCurrentPos
//            zzState = ZZ_LEXSTATE[zzLexicalState]
//
//            // set up zzAction for empty match case:
//            var zzAttributes = zzAttrL[zzState]
//            if (zzAttributes and 1 == 1) {
//                zzAction = zzState
//            }
//            zzForAction@ while (true) {
//                if (zzCurrentPosL < zzEndReadL) {
//                    zzInput = zzBufferL[zzCurrentPosL].code
//                    zzCurrentPosL += charCount(zzInput)
//                } else if (zzAtEOF) {
//                    zzInput = YYEOF
//                    break@zzForAction
//                } else {
//                    // store back cached positions
//                    zzCurrentPos = zzCurrentPosL
//                    zzMarkedPos = zzMarkedPosL
//                    val eof = zzRefill()
//                    // get translated positions and possibly new buffer
//                    zzCurrentPosL = zzCurrentPos
//                    zzMarkedPosL = zzMarkedPos
//                    zzBufferL = zzBuffer
//                    zzEndReadL = zzEndRead
//                    if (eof) {
//                        zzInput = YYEOF
//                        break@zzForAction
//                    } else {
//                        zzInput = zzBufferL[zzCurrentPosL].code
//                        zzCurrentPosL += charCount(zzInput)
//                    }
//                }
//                val zzNext = zzTransL[zzRowMapL[zzState] + ZZ_CMAP(zzInput)]
//                if (zzNext == -1) break@zzForAction
//                zzState = zzNext
//                zzAttributes = zzAttrL[zzState]
//                if (zzAttributes and 1 == 1) {
//                    zzAction = zzState
//                    zzMarkedPosL = zzCurrentPosL
//                    if (zzAttributes and 8 == 8) break@zzForAction
//                }
//            }
//
//
//            // store back cached position
//            zzMarkedPos = zzMarkedPosL
//            if (zzInput == YYEOF && tokenStart == zzCurrentPos) {
//                zzAtEOF = true
//                zzDoEOF()
//                when (zzLexicalState) {
//                    BLOCK_COMMENT_STATE, DOC_COMMENT_STATE -> {
//                        val state = yystate()
//                        popState()
//                        tokenStart = commentStart
//                        return commentStateToTokenType(state)
//                    } // fall though
//                    53 -> {}
//                    54 -> {}
//                    else -> return null
//                }
//            } else {
//                when (if (zzAction < 0) zzAction else ZZ_ACTION[zzAction]) {
//                    1 -> return BAD_CHARACTER
//                    41, 79, 80, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 52, 53, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42 -> {}
//                    2 -> return WHITE_SPACE
//                    3 -> return TAG
//                    4 -> return IDENTIFIER
//                    5 -> return NUMBER
//                    6 -> return TIMES
//                    7 -> return PLUS
//                    8 -> return MINUS
//                    9 -> return COLUMN
//                    10 -> return SEMICOLUMN
//                    11 -> return LPAREN
//                    12 -> return RPAREN
//                    13 -> return LBRACE
//                    14 -> return RBRACE
//                    15 -> return LBRACKET
//                    16 -> return RBRACKET
//                    17 -> return EQUALS
//                    18 -> return QUESTION
//                    19 -> return DOT
//                    20 -> return TILDE
//                    21 -> return CIRCUMFLEX
//                    22 -> return LESS
//                    23 -> return GREATER
//                    24 -> return DOUBLE_TAG
//                    25 -> return DOUBLE_TAG
//                    26 -> return NAT_LESS
//                    27 -> return BINARY_TAG
//                    28 -> return LINE_COMMENT
//                    29 -> {
//                        pushState(BLOCK_COMMENT_STATE)
//                        commentDepth = 0
//                        commentStart = this.tokenStart
//                        return EQ
//                    }
//                    30 -> return EQ
//                    31 -> return LEQ
//                    32 -> return GEQ
//                    33 -> return NEQ
//                    34 -> {
//                        commentDepth++
//                        if (commentDepth > 0) {
//                            commentDepth--
//                        } else {
//                            val state: Int = yystate()
//                            popState()
//                            this.tokenStart = commentStart
//                            return commentStateToTokenType(state)
//                        }
//                        return HEX_TAG
//                    }
//                    35 -> {
//                        if (commentDepth > 0) {
//                            commentDepth--
//                        } else {
//                            val state: Int = yystate()
//                            popState()
//                            this.tokenStart = commentStart
//                            return commentStateToTokenType(state)
//                        }
//                        return HEX_TAG
//                    }
//                    36 -> return HEX_TAG
//                    37 -> return NAT_LEQ
//                    38 -> return LINE_DOCUMENTATION
//                    39 -> {
//                        pushState(DOC_COMMENT_STATE)
//                        commentDepth = 0
//                        commentStart = this.tokenStart
//                        return BLOCK_COMMENT
//                    }
//                    40 -> return BLOCK_COMMENT
//                    else -> {
//                        zzScanError(ZZ_NO_MATCH)
//                    }
//                }
//            }
//        }
//    }
//
//    companion object {
//        /**
//         * This character denotes the end of file
//         */
//        val YYEOF = -1
//
//        /**
//         * initial size of the lookahead buffer
//         */
//        private val ZZ_BUFFERSIZE = 16384
//
//        /**
//         * lexical states
//         */
//        val YYINITIAL = 0
//        val BLOCK_COMMENT_STATE = 2
//        val DOC_COMMENT_STATE = 4
//
//        /**
//         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
//         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
//         * at the beginning of a line
//         * l is of the form l = 2*k, k a non negative integer
//         */
//        private val ZZ_LEXSTATE = intArrayOf(
//            0, 0, 1, 1, 1, 1
//        )
//
//        /* The ZZ_CMAP_Z table has 68 entries */
//        val ZZ_CMAP_Z = zzUnpackCMap(
//            "\u0001\u0000\u0043\u0080")
//
//        /* The ZZ_CMAP_Y table has 256 entries */
//        val ZZ_CMAP_Y = zzUnpackCMap(
//            "\u0001\u0000\u0001\u0001\u002b\u0002\u0001\u0003\u0012\u0002\u0001\u0004\u001f\u0002\u0001\u0003\u009f\u0002")
//
//        /* The ZZ_CMAP_A table has 640 entries */
//        val ZZ_CMAP_A = zzUnpackCMap(
//            "\u0009\u0000\u0001\u0003\u0001\u0002\u0001\u0001\u0001\u0003\u0001\u0001\u0012\u0000\u0001\u0003\u0001\u001e\u0001\u0000\u0001\u0004\u0001\u0007\u0003\u0000\u0001\u0011\u0001\u0012\u0001\u000c\u0001\u000d" +
//                    "\u0001\u0000\u0001\u000e\u0001\u0019\u0001\u0009\u0002\u0008\u0008\u000a\u0001\u000f\u0001\u0010\u0001\u001c\u0001\u0017\u0001\u001d\u0001\u0018\u0001\u0000\u001a\u000b\u0001\u0015" +
//                    "\u0001\u0000\u0001\u0016\u0001\u001b\u0001\u0006\u0001\u0000\u0006\u0005\u0014\u000b\u0001\u0013\u0001\u0000\u0001\u0014\u0001\u001a\u0006\u0000\u0001\u0001\u001a\u0000\u0001\u0001\u00df\u0000" +
//                    "\u0001\u0001\u007f\u0000\u000b\u0001\u001d\u0000\u0002\u0001\u0005\u0000\u0001\u0001\u002f\u0000\u0001\u0001\u0020\u0000")
//
//        /**
//         * Translates characters to character classes
//         * Chosen bits are [7, 7, 7]
//         * Total runtime size is 1928 bytes
//         */
//        fun ZZ_CMAP(ch: Int): Int =
//            ZZ_CMAP_A[(ZZ_CMAP_Y[ZZ_CMAP_Z[ch shr 14].code or ((ch shr 7) and 0x7f)].code shl 7) or (ch and 0x7f)].code
//
//        /**
//         * Translates DFA states to action switch labels.
//         */
//        private val ZZ_ACTION_PACKED_0 =
//            "\u0002\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0001\u0001\u0005\u0001\u0001" +
//                    "\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000d" +
//                    "\u0001\u000e\u0001\u000f\u0001\u0010\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015" +
//                    "\u0001\u0016\u0001\u0017\u0001\u0001\u0003\u0018\u0001\u0019\u0002\u0000\u0001\u001a\u0001\u001b" +
//                    "\u0002\u0000\u0001\u001c\u0001\u001d\u0001\u001e\u0001\u001f\u0001\u0020\u0001\u0021\u0001\u0022" +
//                    "\u0001\u0023\u0001\u0024\u0001\u0025\u0001\u001c\u0001\u0026\u0001\u0027\u0001\u0028"
//        private val ZZ_ACTION = zzUnpackAction()
//
//        private fun zzUnpackAction(): IntArray {
//            val result = IntArray(52)
//            var offset = 0
//            offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result)
//            return result
//        }
//
//        private fun zzUnpackAction(packed: String, offset: Int, result: IntArray): Int {
//            var i = 0 /* index in packed string  */
//            var j = offset /* index in unpacked array */
//            val l = packed.length
//            while (i < l) {
//                var count = packed[i++].code
//                val value = packed[i++].code
//                do result[j++] = value while (--count > 0)
//            }
//            return j
//        }
//
//        /**
//         * Translates a state to a row index in the transition table
//         */
//        private val ZZ_ROWMAP_PACKED_0 =
//            ("\u0000\u0000\u0000\u001f\u0000\u003e\u0000\u005d\u0000\u007c\u0000\u009b\u0000\u00ba\u0000\u00d9" +
//                    "\u0000\u00f8\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e" +
//                    "\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u0117\u0000\u003e\u0000\u003e\u0000\u003e" +
//                    "\u0000\u003e\u0000\u0136\u0000\u0155\u0000\u0174\u0000\u003e\u0000\u0193\u0000\u01b2\u0000\u003e" +
//                    "\u0000\u01d1\u0000\u01f0\u0000\u020f\u0000\u003e\u0000\u022e\u0000\u024d\u0000\u026c\u0000\u028b" +
//                    "\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e\u0000\u003e" +
//                    "\u0000\u02aa\u0000\u02c9\u0000\u02e8\u0000\u003e")
//        private val ZZ_ROWMAP = zzUnpackRowMap()
//
//        private fun zzUnpackRowMap(): IntArray {
//            val result = IntArray(52)
//            var offset = 0
//            offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result)
//            return result
//        }
//
//        private fun zzUnpackRowMap(packed: String, offset: Int, result: IntArray): Int {
//            var i = 0 /* index in packed string  */
//            var j = offset /* index in unpacked array */
//            val l = packed.length
//            while (i < l) {
//                val high = packed[i++].code shl 16
//                result[j++] = high or packed[i++].code
//            }
//            return j
//        }
//
//        /**
//         * The transition table of the DFA
//         */
//        private val ZZ_TRANS_PACKED_0 =
//            ("\u0002\u0003\u0002\u0004\u0001\u0005\u0002\u0006\u0001\u0007\u0001\u0008\u0001\u0009\u0001\u0008" +
//                    "\u0001\u0006\u0001\u000a\u0001\u000b\u0001\u000c\u0001\u000d\u0001\u000e\u0001\u000f\u0001\u0010" +
//                    "\u0001\u0011\u0001\u0012\u0001\u0013\u0001\u0014\u0001\u0015\u0001\u0016\u0001\u0017\u0001\u0018" +
//                    "\u0001\u0019\u0001\u001a\u0001\u001b\u0001\u001c\u0009\u001d\u0001\u001e\u0002\u001d\u0001\u001f" +
//                    "\u0012\u001d\u0021\u0000\u0002\u0004\u001f\u0000\u0001\u0020\u0001\u0021\u0001\u0022\u0001\u0000" +
//                    "\u0001\u0021\u0001\u0000\u0001\u0021\u0011\u0000\u0001\u0023\u0007\u0000\u0002\u0006\u0001\u0000" +
//                    "\u0001\u0006\u0001\u0000\u0002\u0006\u0014\u0000\u0003\u0024\u0002\u0000\u0001\u0025\u0001\u0000" +
//                    "\u0001\u0026\u001e\u0000\u0001\u0008\u0001\u0000\u0001\u0008\u001d\u0000\u0001\u0027\u0002\u0000" +
//                    "\u0001\u0028\u0029\u0000\u0001\u0029\u001e\u0000\u0001\u002a\u001e\u0000\u0001\u002b\u001e\u0000" +
//                    "\u0001\u002c\u0013\u0000\u0001\u002d\u001b\u0000\u0001\u002e\u0016\u0000\u0003\u002f\u0001\u0000" +
//                    "\u0001\u0021\u0001\u0022\u0001\u0000\u0001\u0021\u0001\u0000\u0001\u0021\u0015\u0000\u0003\u002f" +
//                    "\u0032\u0000\u0001\u0030\u0008\u0000\u0003\u0024\u001c\u0000\u0003\u0024\u0004\u0000\u0001\u0026" +
//                    "\u0016\u0000\u0002\u0031\u0001\u0000\u0006\u0031\u0001\u0032\u0015\u0031\u000c\u0000\u0001\u0033" +
//                    "\u0012\u0000\u0002\u0031\u0001\u0000\u001c\u0031\u0002\u0032\u0001\u0000\u001c\u0032\u0009\u0000" +
//                    "\u0001\u0034\u0015\u0000")
//        private val ZZ_TRANS = zzUnpackTrans()
//
//        private fun zzUnpackTrans(): IntArray {
//            val result = IntArray(775)
//            var offset = 0
//            offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result)
//            return result
//        }
//
//        private fun zzUnpackTrans(packed: String, offset: Int, result: IntArray): Int {
//            var i = 0 /* index in packed string  */
//            var j = offset /* index in unpacked array */
//            val l = packed.length
//            while (i < l) {
//                var count = packed[i++].code
//                var value = packed[i++].code
//                value--
//                do result[j++] = value while (--count > 0)
//            }
//            return j
//        }
//
//        /* error codes */
//        private val ZZ_UNKNOWN_ERROR = 0
//        private val ZZ_NO_MATCH = 1
//        private val ZZ_PUSHBACK_2BIG = 2
//
//        /* error messages for the codes above */
//        private val ZZ_ERROR_MSG = arrayOf(
//            "Unknown internal scanner error",
//            "Error: could not match input",
//            "Error: pushback value was too large"
//        )
//
//        /**
//         * ZZ_ATTRIBUTE[aState] contains the attributes of state `aState`
//         */
//        private val ZZ_ATTRIBUTE_PACKED_0 =
//            ("\u0002\u0000\u0001\u0009\u0006\u0001\u000b\u0009\u0001\u0001\u0004\u0009\u0003\u0001\u0001\u0009" +
//                    "\u0002\u0001\u0001\u0009\u0002\u0000\u0001\u0001\u0001\u0009\u0002\u0000\u0002\u0001\u0008\u0009" +
//                    "\u0003\u0001\u0001\u0009")
//        private val ZZ_ATTRIBUTE = zzUnpackAttribute()
//
//        private fun zzUnpackAttribute(): IntArray {
//            val result = IntArray(52)
//            var offset = 0
//            offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result)
//            return result
//        }
//
//        private fun zzUnpackAttribute(packed: String, offset: Int, result: IntArray): Int {
//            var i = 0 /* index in packed string  */
//            var j = offset /* index in unpacked array */
//            val l = packed.length
//            while (i < l) {
//                var count = packed[i++].code
//                val value = packed[i++].code
//                do result[j++] = value while (--count > 0)
//            }
//            return j
//        }
//
//        /**
//         * Unpacks the compressed character translation table.
//         *
//         * @param packed the packed character translation table
//         * @return the unpacked character translation table
//         */
//        private fun zzUnpackCMap(packed: String): CharArray {
//            var size = 0
//            run {
//                var i = 0
//                val length: Int = packed.length
//                while (i < length) {
//                    size += packed[i].code
//                    i += 2
//                }
//            }
//            val map = CharArray(size)
//            var i = 0 /* index in packed string  */
//            var j = 0 /* index in unpacked array */
//            while (i < packed.length) {
//                var count = packed[i++].code
//                val value = packed[i++]
//                do map[j++] = value while (--count > 0)
//            }
//            return map
//        }
//    }
//
//    private fun charCount(codePoint: Int) = if (codePoint >= 65536) 2 else 1
//}